[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1440
PlayResY: 860

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: D:/Downloads/Telegram Desktop/电脑批量测试【原创首发】/新建文件夹/最简化任意多个绘图间连续变形转化.mp4
Video File: D:/Downloads/Telegram Desktop/电脑批量测试【原创首发】/新建文件夹/最简化任意多个绘图间连续变形转化.mp4
Video AR Mode: 4
Video AR Value: 1.674419
Video Zoom Percent: 0.625000
Scroll Position: 9
Active Line: 15
Video Position: 19604

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,更纱黑体 SC Semibold,40,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:03.91,0:01:53.98,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:05:23.76,0:06:45.54,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:10:25.28,0:12:27.78,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:00:03.98,0:00:45.95,Default,,0,0,0,,{\fs32}有了上个视频讲的将任意两个"标准"绘图代码统一的函数，就可以做出任意绘图连续变形为另一个任意绘图的效果了\N而且这样还是最简化的方法,因为变形过程中的"中间态"绘图的命令是“不多不少”的,而不像之前视频用的那种全部变贝塞尔\N的方法，全部变贝塞尔再变形的话，计算出的"中间态"绘图就有一大堆b白白增加文本量，所以现在这种方法不仅节约文本量\N而且执行速度也够快，是上好方案！该直线时就直线、该曲线时就曲线、不多不少！
Dialogue: 0,0:00:45.95,0:01:38.55,Default,,0,0,0,,代码还是一个道理。先一开始就把输入的两个绘图的结构给统一了，不用for循环每次都执行重复的\N操作。然后这里for循环里计算"中间态"绘图的函数还是之前讲的toshape_at_pct函数，因为那个函\N数只是负责计算变形进度是pct时，点的坐标是什么并把绘图1相应的点替换掉而已，所以说,只要你\N给toshape_at_pct函数填的是两个结构一样的绘图的话,函数当然就能计算"中间态"绘图，之前也说\N过，toshape_at_pct函数填的绘图有没有直线都可以，只要结构一样的俩绘图就可以了。所以这里\N用到的还是之前讲的toshape_at_pct函数来计算"中间态"的绘图
Dialogue: 0,0:02:48.15,0:03:11.71,Default,,0,0,0,,显然现在的绘图就有直线也有曲线，就不像之前的视频讲的方法(全部都是贝塞尔)
Dialogue: 0,0:04:36.28,0:05:06.35,Default,,0,0,0,,当然变形的效果和用之前的方法做的变形效果一样
Dialogue: 0,0:05:35.78,0:06:26.14,Default,,0,0,0,,然后当然，除了从绘图1变形到绘图2，还有从绘图1一路变形到绘图n，函数写的方法和之前一样\N只不过唯一的区别就是，这里的操作是将两个绘图最简化的统一,而不是之前那样全变贝塞尔再统一
Dialogue: 0,0:07:44.71,0:07:58.01,Default,,0,0,0,,多个绘图的连续变形函数，第一个参数当然还是填一个表，一个装有绘图1到绘图n的表
Dialogue: 0,0:07:58.01,0:08:19.39,Default,,0,0,0,,现在就装了3个绘图，所以是绘图1变形到绘图2，绘图2再变形到绘图3
Dialogue: 0,0:08:33.24,0:08:52.96,Default,,0,0,0,,还是一样的，你也可以装更多个绘图
Dialogue: 0,0:09:19.73,0:10:02.18,Default,,0,0,0,,哦对了，如果觉得变形效果太唐突的话，可以配合拆字来做。也就是说，比如你觉得一个心形变为\N一个文字绘图看起来不好看，那么你可以用拆字把文字给拆成多个部件，比如某个字拆出了3个部分\N那么就设定3个心形,每个心形只变形成为相应的一部分而已。比如说“回”这个字拆字拆出两个部\N分，那么就用2个心形，第一个心形变形为你拆的第一部分，第二个心形变形为你拆出的第二个部分\N
Dialogue: 0,0:10:02.18,0:10:17.78,Default,,0,0,0,,{\fs36}现在设定了加速度是2.5，注意这个加速度是每一段变形的加速度，而不是绘图1一路变形到绘图n的加速度\N如果你想要整个过程的加速度的话，自己改写一下函数即可
Dialogue: 0,0:10:45.21,0:11:39.98,Default,,0,0,0,,{\fs34}好了，之前说了，由于在产生"中间态"绘图的函数中，不需要每次for循环都执行一遍统一绘图结构的操作，所以在\Ntoshape_at_pct函数里删除掉了这个操作，并限制该toshape_at_pct函数的参数只能填结构相同的绘图代码。所以\N说，如果你只想生成一个"中间态"绘图的话，比如变形进度为0.23时的绘图的话，那可以再加一个at_percent函数嘛\N让这个函数允许输入两个任意的"标准"绘图代码，然后在at_percent函数内部执行将两个绘图结构统一的操作，然后\N再来计算中间态绘图就好了，这样的话你就能单独得到一个变形进度为percent时的中间态绘图，就自由一些了。
Dialogue: 0,0:11:42.01,0:12:09.09,Default,,0,0,0,,{\fs34}这样的话，这个toshape_at_percent函数反正是拿来单独用的，没有用在生成一堆"中间态"绘图的函数里，当然不会\N影响到那个函数的执行速度了。然后这些绘图显然都是保留最多两位小数的,如果想只保留1位,可以自己改函数的代码
Dialogue: 0,0:12:09.09,0:12:11.09,Default,,0,0,0,,
