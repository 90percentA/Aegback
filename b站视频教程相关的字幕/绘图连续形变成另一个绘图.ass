[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1440
PlayResY: 860

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: D:/Downloads/Telegram Desktop/电脑批量测试【原创首发】/新建文件夹/绘图连续形变成另一个绘图.mp4
Video File: D:/Downloads/Telegram Desktop/电脑批量测试【原创首发】/新建文件夹/绘图连续形变成另一个绘图.mp4
Video AR Mode: 4
Video AR Value: 1.674419
Video Zoom Percent: 0.750000
Scroll Position: 67
Active Line: 67
Video Position: 76550

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,更纱黑体 SC Semibold,40,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:01:42.28,0:07:02.96,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:09:43.66,0:17:19.34,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:19:53.48,0:24:54.78,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:26:37.71,0:26:47.99,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:28:54.81,0:31:07.91,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:31:35.24,0:31:41.51,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:36:13.69,0:36:21.01,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:36:51.48,0:37:03.46,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:38:21.34,0:45:15.03,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:48:30.81,0:48:47.18,Default,,0,0,0,,{\p1\c&H1E1E1E&\bord0\shad0\pos(376.983,20.573)}m 59 67 l 821 65 818 85 62 85
Dialogue: 0,0:00:02.08,0:01:34.55,Default,,0,0,0,,先看看绘图连续变形为另一个绘图的效果
Dialogue: 0,0:01:34.55,0:02:32.99,Default,,0,0,0,,对于两个结构一样的绘图，是很方便就能实现连续变形的。举个例子，m 5 7要变为m 23 66很简\N单吧，假设用0表示变化开始1表示变化结束,那么变形过程的0.5时候，m 5 7就该变成m 14 29.5\N对吧。变形进度用百分比pct表示吧(即percent)，pct=0时5是5，pct=23时5变成23，pct=0.5时\N5变成的是14，因为5+(23-5)*pct等于14，当然这样的变形是"线性"的。所以同理，如果两个绘图\N是m 0 0 l 2 7和m 23 6 l 7 5的话，就这两个绘图的每一个点都像刚刚那样变化即可,第一个点0,0\N对应会变化到第二个绘图的第一个点；第一个绘图第二个点2,7会对应变化到第二个绘图第二个点7,\N5，所以如果变形进度为0.5时(即变形进行到整个变形过程的中间时)就会得到m 11.5 3 l 4.5 6
Dialogue: 0,0:02:32.99,0:03:48.99,Default,,0,0,0,,{\fs36}由于一般两个绘图的结构不会一样，比如m 0 0 l 24 11 l 21 20和m 0 0 l 8 -4 m 5 4 b 2 3 0 3 -3 2 l -4 4就\N不一样，因为它们的绘图命令不是对应相同的，就不能直接像刚刚那样计算点在中间过程的坐标了。所以这里\N先来介绍第一种方法，即把两个任意绘图先全部去掉l命令，也就是之前讲的把直线命令替换为贝塞尔命令，然\N{\fs30}后再把两个都是贝塞尔路径的绘图变为结构相同的绘图,比如m 0 0 b 5 -1 10 -2 15 -3和m 0 0 b -1 0 -2 1 -3 1 b -3 2 -2 3 -2 4就\N{\fs36}是两个不同结构的只有b路线的绘图，这样的话就再在后面加一条b命令并且不改变原绘图即可，所以可以将第\N一个绘图变为m 0 0 b 5 -1 10 -2 15 -3 b 15 -3 15 -3 15 -3就行了，这样虽然加了一个b,但是绘图形状不变,\N因为加的这个b 15 -3 15 -3 15 -3不就是一个"点"吗，而且当然是第一个绘图的最后一个点15 -3了。所以现\N在先写一个统一两个只剩b路线的单m绘图,所以这个check_coor_m函数要填两个没有直线命令的绘图且这两\N个绘图都是单m绘图，不能由多个m构成。
Dialogue: 0,0:03:48.99,0:05:15.45,Default,,0,0,0,,{\fs31}那么怎么将两个单m、无直线的绘图结构统一呢？这个很简单，这样的绘图无非是m x y 后面加一堆b x2 y2 x3 y3 x4 y4命令\N而已，对吧。那么首先检查两个输入的绘图是否结构一样，说白了现在就是检测它们的b的数量一不一样，这里用了gsub函数来\N匹配"b"这个字符串，当然gsub一般用来替换的，但是gsub本身是会返回两个返回值的，第一个是替换后的字符串，第二个是它\N在搜索替换时，有几次匹配成功了，所以这样视频中的n1和n2就是知道了两个绘图里有多少个b命令,然后谁的b命令少就往谁后\N面补足b命令。那么补的b命令里的坐标是什么呢，就是你要补的那个绘图的最后一个点的坐标,因为你补的命令肯定要连接在最\N后面，而且不能改变你要补的这个绘图的形状，所以比如m 0 0 b 6 3 11 7 17 10如果要补3个b命令的话就是在后\N面加三个b 17 10 17 10 17 10
Dialogue: 0,0:05:15.45,0:06:35.01,Default,,0,0,0,,因为考虑到有时候你输入的绘图代码最后面可能没有空格，所以匹配最后一个点的时候，最后不匹\N配空格,因为如果没有空格的话，匹配到的东西里面就有可能有空格有可能没有空格，所以为了方便\N直接用括号()分组匹配一下，只匹配出最后的一个[-.%d]+ [-.%d]+最后一个点。然后用这个点连\N接成一个b命令。然后string.rep函数很早很早就讲过,用它来配合形成一个b命令。很显然名叫add\N的这个字符串，它就是比如b 2 6 2 6 2 6 这样的，当然最后是有空格的，因为这些b命令后面还要\N连起来呢。刚刚说了差了几个b就要补几个,所以名叫add的这字符串就要用string.rep函数重复几遍\N并连接到要补的这个绘图的后面。刚刚说了，n1是第一个绘图的b命令数目，n2是第二个绘图的b命\N令总数，所以比如n1>n2时，第一个绘图就比第二个绘图多n1-n2个b命令，所以要把刚刚得到的b\N命令、也就是add这个字符串用string.rep重复n1-n2次，并连接到要补的第二个绘图后面
Dialogue: 0,0:06:35.01,0:06:55.78,Default,,0,0,0,,然后这个函数最后就返回结构统一后的没有直线的且单m的两个绘图
Dialogue: 0,0:07:29.31,0:07:52.88,Default,,0,0,0,,注意刚刚说了，这个函数的参数必须填两个单m且没有直线命令的绘图
Dialogue: 0,0:08:29.21,0:08:37.99,Default,,0,0,0,,现在显然第一个绘图的b命令数量就和第二个一样了，所以这两个绘图的结构就肯定一样了
Dialogue: 0,0:08:37.99,0:08:49.99,Default,,0,0,0,,当然这个函数会返回两个返回值，现在这样用当然只能看到返回的第一个值，现在只是要看看这个\N函数实际的效果而已
Dialogue: 0,0:09:04.51,0:09:24.38,Default,,0,0,0,,可见，第一个绘图后面就连接了相应数目的b 60 26 60 26 60 26
Dialogue: 0,0:09:50.38,0:11:42.31,Default,,0,0,0,,{\fs36\fn思源黑体 CN Medium}那么现在是第二个问题，如果是两个有多个m的绘图，怎么将他们的结构统一呢？\N比如m 0 0 b 6 3 11 7 17 10和m 0 0 b 3 -2 6 -4 9 -6 b 10 0 11 7 12 13 m 20 -1 b 19 1 19 3 18 5 b 21 5 24 5 27 5 b 26 0 25 -6 24 -11\N第一个绘图有一个m有一个b，第二个绘图有两个m，第一个m有两个b，第二个m有3个b。所以此时需要按m来拆开两个绘图，当然\N由于最后的目的是对任意两个绘图进行变形，所以这里设定参数可以填任意的标准的绘图字符串，然后不管是你填的绘图代码有没有\N直线命令，该函数第一句代码就直接帮你把所有直线命令都替换为贝塞尔，用之前讲的函数，\N比如ass_shape1=Xshape.bezier_all(ass_shape1)以后，第一个绘图当然就只剩下曲线路径了。然后再来把只有曲线路径的两个绘\N图进行结构统一，当然就要按m来把两个绘图给拆开，然后当然要比较谁的m多了，因为m少的绘图就需要补m了
Dialogue: 0,0:11:42.31,0:12:26.04,Default,,0,0,0,,如果两个绘图的m数量一样的话，只需要两个绘图的每个m都对应的进行结构统一即可，而单个m的\N两个字符串要统一结构的话，当然就用刚刚讲的第一个函数作为辅助函数即可。因为m数量一样,所\N以直接for从1到#s1对每个s1[i]和s2[i]的结构进行统一
Dialogue: 0,0:12:26.04,0:13:27.18,Default,,0,0,0,,如果两个绘图的m数量不一样的话,就先把他们的m数量变为一样的,然后再对他们的每一个对应的m\N的结构进行统一。那么补m的话怎么补呢,比如第一个绘图有3个m，第二个绘图有7个m，那么从第\N一个m到第三个m两个绘图都可以找到对应，从第四个m开始，第一个绘图就没有m和第二个绘图的\Nm对应了，所以就要在第一个绘图后面补4个m，且每个m的结构当然得对应着第二个绘图的相应的\Nm来。所以这样的话,第一个绘图补的第4个m的结构应和第二个绘图的第4个m的结构一样、第一个\N绘图的第5个m的结构应和第二个绘图的第5个m的结构一样，以此类推。
Dialogue: 0,0:13:27.18,0:14:15.99,Default,,0,0,0,,那么当然，补m的时候照样和刚刚一样，不能改变原绘图的形状，所以还是获取要补的那个绘图的\N最后一个点，然后直接在前面连个m即可，比如连接成m 23 66这样的，然后比如第二个绘图的m\N少一些，那么当然这个m就要放进s2里面，当然要补几个m就放几个进去。然后很舒服的是，刚刚\N不是说补的m要和另一个绘图的相应的m结构一样吗，那实际上用刚刚的对单m进行统一的函数即可\N{\fs37}刚刚讲的第一个函数就可以把比如m 0 5和m 5 8 b 9 10 13 12 17 14给统一成一个是m 0 5 b 0 5 0 5 0 5\N一个是m 5 8 b 9 10 13 12 17 14的样子。
Dialogue: 0,0:14:15.99,0:14:55.99,Default,,0,0,0,,因为刚刚的第一个函数会检测两个绘图的b数量，所以就算是m 0 5和m 5 8 b 9 10 13 12 17 14也\N可以统一，因为这种只需要补相应数量的b即可。所以现在不用考虑别的，现在只用把这两个绘图\N的m的数量统一了。然后添加了m以后两个绘图现在的m数目就一样了，所以直接循环比如#s1次,\N然后用讲的第一个函数来把两个绘图的对应的每个m都进行结构统一，这样最后的时候连接两个表\N即可得到两个结构一样的、没有直线的多m绘图
Dialogue: 0,0:15:09.18,0:15:56.54,Default,,0,0,0,,然后s1和s2两个表正常来说,要不然相等，要不然#s1>#s2要不然#s2>#s1，所以这里就不写elseif\N了，不用写elseif #s2>#s1了，直接写else。然后当然，这种情况下的操作也和刚刚一样，如果\N第二个绘图的m比第一个绘图多，那么现在就往第二个绘图后面补m即可，都是一个道理和刚刚
Dialogue: 0,0:17:09.24,0:17:50.73,Default,,0,0,0,,最后把s1、s2两个表里面的东西处理好以后，就用concat连接得到新的字符串即可\N显然,该函数返回两个值。该函数可填任意两个"标准"的绘图字符串，然后函数返回两个结构一样、\N没有直线的、只有贝塞尔路线的"多m"绘图(当然如果填的参数是两个单m绘图返回就是单m的,这不\N是废话吗，不要说也知道吧。这里还是严谨一点..)
Dialogue: 0,0:18:00.58,0:18:39.68,Default,,0,0,0,,可以看到，第一个绘图只有一个m，第二个绘图有多个m，然后用这个函数就把它们的结构统一了\N
Dialogue: 0,0:18:39.68,0:18:47.68,Default,,0,0,0,,当然显然，并没有改变两个绘图的形状
Dialogue: 0,0:19:44.11,0:20:28.94,Default,,0,0,0,,那么接下来，两个绘图的结构都一样了，这个时候不就可以直接像一开始说的那样，直接变形了吗\N就只是把第一个绘图的对应的点的坐标给渐渐变为第二个绘图的对应的点的坐标即可。当然这里就\N直接用线性的变化即可。所以假设一点x0,y0要变化到x1,y1的话，如果此时变化的进度设为pct的话\N那么此时这一点的坐标当然就为：横坐标为x0+(x1-x0)*pct，纵坐标为y0+(y1-y0)*pct
Dialogue: 0,0:20:28.94,0:21:14.98,Default,,0,0,0,,所以这样就写一个toshape_at_pct函数，这里设定了4个参数，前两个填任意的"标准"的绘图代码\N有没有直线命令无所谓，因为经过刚刚的函数，这两个绘图会成结构一样的没有直线命令的绘图，\N然后第三个参数填变形的进度，从百分之0到百分之100即0到1都可以，最后一个参数设定加速度\N就是变形的加速度，前面说的是线性的，现在加入一个加速度以后计算就变成x0+(x1-x0)*pct^a了\N其中a为加速度。当然现在函数有默认设定加速度为1，你不填加速度这个参数也可以,因为一般都是\N默认加速度为1的变形。
Dialogue: 0,0:21:14.98,0:21:25.71,Default,,0,0,0,,因为参数填的是任意两个“标准”的绘图代码，所以先用刚刚讲的函数将两个绘图结构统一一下
Dialogue: 0,0:21:25.71,0:21:33.99,Default,,0,0,0,,然后要把绘图里的数取出来，用来计算，所以建立两个表coor1、coor2
Dialogue: 0,0:21:33.99,0:22:01.94,Default,,0,0,0,,有了数以后，就可以实施刚才说的计算方式了。只要把原本绘图里的数给替换为计算出的数即可。\N所以用gsub替换，那么这里涉及一个问题，你替换的时候怎么知道替换的是第几个数呢，对吧，所\N以需要一个计数的变量cnt，让gsub每匹配一次cnt就加1，这样此时匹配出的数是第几个就可以用\Ncnt来知晓了
Dialogue: 0,0:22:01.94,0:22:37.48,Default,,0,0,0,,用gsub替换，一次匹配一个数，假设这个数名叫num吧，那么匹配到几次cnt此时计算时就是几，\N所以此时对应的第一个绘图的数是coor1[cnt]，第二个绘图对应的数就是coor2[cnt]，所以计算要\N替换成什么数就是这样计算的： num=num+(coor2[cnt]-coor1[cnt])*pct^Accel\N最后当然要取舍一下小数位数，不然得到的这个数很可能小数点后面有一大堆
Dialogue: 0,0:22:37.48,0:23:58.88,Default,,0,0,0,,{\pos(720,477)}关于这个gsub的替换，再说形象一点，比如0 2 7 6这么一个字符串如果要替换为3 4 9 23.333的\N话，就比如用一个表p6qgub  =｛3,4,9,23.333｝还有一个cnt计数的变量，然后gsub,每次匹配\N一个数，第一次匹配到0，然后它要替换为3也就是p6qgub[1]，此时cnt等于1，然后获得了要替换\N成什么数以后，cnt就加一，这样下一次匹配的时候，cnt就等于2，所以第二次匹配时匹配到那个\N字符串0 2 7 6其中的2，然后这个2要替换成为p6qgub[2]，知道被替换为的是p6qgub[2]以后，\Ncnt就加1变成了3，以此类推。这样就能完成把0 2 7 6替换为3 4 9 23.333的任务。对吧。如果\N没有cnt来计数的话，那gsub匹配的时候，比如匹配到数字7了，你怎么知道现在是第几个数了呢\N对吧，所以cnt计数就能让你知道匹配到7时，是匹配到第三个数了
Dialogue: 0,0:23:58.88,0:24:17.99,Default,,0,0,0,,{\fs36}然后现在这个函数返回一个绘图代码，这个绘图代码是ass_shape1向ass_shape2变形、变形到pct这个\N进度时的绘图。比如pct填的0.5那么就是绘图一向绘图二变形、变形到一半时的绘图代码
Dialogue: 0,0:24:17.99,0:24:56.28,Default,,0,0,0,,那么有了toshape_at_pct函数以后，你就可以知道整个变形过程会得到什么样的绘图了。比如变形\N进度为0的时候是什么绘图，比如变形进度是0.233时是变形成了什么绘图，比如变形进度是1时,是\N变形成了什么绘图。这样的话,就可以用它来生成很多"张"绘图，这些绘图一帧一帧的出现的话，看\N起来不就是一个动态的连续变形效果吗、不就是绘图一连续变形成为绘图二的效果吗？
Dialogue: 0,0:24:56.28,0:25:17.74,Default,,0,0,0,,现在先来看看toshape_at_pct函数的结果
Dialogue: 0,0:26:54.51,0:27:01.08,Default,,0,0,0,,可以看到，现在就得到了绘图一变形到绘图二的进度是0.5时(一半)的绘图
Dialogue: 0,0:28:34.38,0:28:41.11,Default,,0,0,0,,还是很明显吧，应该没有什么问题
Dialogue: 0,0:29:07.18,0:29:38.58,Default,,0,0,0,,然后就是toshape函数了。一共6个参数，前两个填任意的"标准"绘图代码，第三四个参数填开始时\N间和结束时间，就是说你想在这段时间里做一个连续变形的效果，所以当然要生成一定数量的"中间\N态"的绘图，第五个参数填间隔时间，比如你想逐帧的话，这里当然就是一帧的时间长度了，第六个\N参数设定变形的加速度。
Dialogue: 0,0:29:38.58,0:30:14.11,Default,,0,0,0,,比如你要在0到1000ms里做绘图一变形到绘图二的效果，那么就需要生成很多"中间态"的绘图，它\N们最后装在一个表里即可舒服使用,用retime调一调时间就可以让这些图一个个出现形成连续效果了\N所以产生很多绘图到底是多少呢，就要设定间隔时间，\N{\fs36}比如间隔时间是10ms那么就要产生(1000-0)/10这么多个"中间态"的绘图,当然一般除不尽所以用ceil来取整
Dialogue: 0,0:30:14.11,0:30:50.68,Default,,0,0,0,,有多少个"中间态"绘图就循环多少次来产生它们,那么每一次循环的当前进度当然是(i-1)/(loop-1)了\N所以你变形的进度pct就知道了，那么此时就用刚才讲的toshape_at_pct函数即可生成相应的绘图\N然后把一次次产生的绘图给储存在名叫shapes这个表里即可。最后函数返回这个装有很多绘图的表
Dialogue: 0,0:30:50.68,0:31:15.31,Default,,0,0,0,,其实之前讲过逐帧，所以这里应该是不难理解的，比如从0到1000ms逐帧，每帧长10ms的话，就\N有(1000-0)/10这么多帧，所以你就需要这么多"张"绘图，所以要循环这么多次来产生"中间态"绘图
Dialogue: 0,0:31:24.76,0:31:34.54,Default,,0,0,0,,因为toshape函数刚才说了，返回一个表，所以在code行用（省略：啊啊啊啊啊）
Dialogue: 0,0:31:47.31,0:31:59.94,Default,,0,0,0,,我们假设变形过程就是从行开始时间开始变形，行结束时间结束变形
Dialogue: 0,0:32:03.18,0:32:09.58,Default,,0,0,0,,然后，间隔时间也就是一帧的长度就好了
Dialogue: 0,0:32:51.08,0:34:00.00,Default,,0,0,0,,这里retime的开始时间就是(j-1)*$ldur/maxj,不用(j-1)*fdur是因为持续时间duration/fdur不一定\N是整数。比如你要做0到100ms的逐帧效果，若fdur=16的话，就有6.25帧，所以要取个整，实际\N循环7次，那么如果你循环7次每一次差的时间还是16ms的话，那7次完成的实际用时是7*16=112\N就超过100ms了，但是你希望的是0到100ms的变化效果不是吗，所以不如在调整retime的时候，\N每一次的持续时间不设为fdur,而设定为(100-0)/7，这样每一份的时间相同而且最后刚好到100ms\N就结束效果了，当然这样的话每一次的持续时间就大约是14.285了，但是这完全没有什么"影响"
Dialogue: 0,0:34:07.54,0:34:12.58,Default,,0,0,0,,来看看现在产生的效果
Dialogue: 0,0:34:12.58,0:34:35.11,Default,,0,0,0,,啊对，别看这个抖，抖是因为现在挂的是VSFilterMod，用VSFilter滤镜就不会看起来抖了。\NVSFilter和VSFilterMod这两个滤镜的算法还是有不小的区别的
Dialogue: 0,0:34:35.11,0:35:00.54,Default,,0,0,0,,可以看到，现在生成的绘图就是一堆b，因为任意两个绘图的结构大概率是不同的，所以用刚刚讲的\N一堆东西把两个绘图的直线命令都先全部替换为b命令,然后在相应的补上b或补上m，使两绘图结构\N一样，这样再来计算点的坐标并进行替换的，所以产生的绘图当然有一堆的b了。
Dialogue: 0,0:36:34.34,0:36:53.94,Default,,0,0,0,,那么你可能会问，这样暴力地实现变形效果，b这么多，文本量这么多，有没有什么办法"简化"文\N本量呢？当然有，而且有又快又好的方法，那么这个在下一次教程的视频进行介绍
Dialogue: 0,0:36:53.94,0:37:17.51,Default,,0,0,0,,当然函数还有一个加速度参数，不填当然默认为1，现在填一下看看效果
Dialogue: 0,0:37:24.71,0:37:32.38,Default,,0,0,0,,可以看到，加速度填2.5时，变形的速度就越来越快，一开始变形得慢后面变形得快
Dialogue: 0,0:37:32.38,0:37:46.88,Default,,0,0,0,,然后现在加速度填0.5看看。显然效果就是变形的速度越来越慢，一开始变形快到后面变形就慢了
Dialogue: 0,0:38:13.13,0:38:31.94,Default,,0,0,0,,可以看到加速度特别小的话，一开始变形就特别快，嗖的一下、啊嗖的一下，就从原绘图变成另一\N副模样了，然后当然因为加速度小，那么变形速度就会从一开始的很快变为很慢了
Dialogue: 0,0:38:32.94,0:39:44.99,Default,,0,0,0,,{\fs32\pos(720,555.695)}那么现在来仔细观察一下代码，是否觉得有些部分是可以优化的？是否觉得现在的代码"拖慢"了执行速度？其实,这个还是要\N让大家学得更清楚，如何简单地看一下怎么改代码、怎么提高执行速度。现在实现toshape函数用的是for循环、每次循环都\N执行toshape_at_pct函数对吧，那么toshape_at_pct函数又是怎样呢，欸，toshape_at_pct函数代码里有把两个任意绘图\N统一的操作，就是说你任意填两个绘图，要把它们统一就需要执行一堆代码,如果俩绘图结构要统一的话,你执行一次统一操作\N不就已经把它们统一完了吗，那你每次for循环每次都执行toshape_at_pct函数，而该函数每次都会重新把你输入的两个绘图\N给执行一下统一结构的操作,那不是白白浪费时间吗？所以要把统一绘图结构的操作从toshape_at_pct函数里删除,然后当然\N在toshape函数里一开始就把两个绘图的结构统一不就完了吗，这样统一结构的操作只用执行一次,不用跟着for循环执行多次\N然后当然这样改以后，toshape_at_pct函数的参数就不能填任意两个"标准"的绘图了，而是要填结构统一的绘图
Dialogue: 0,0:39:44.99,0:40:29.11,Default,,0,0,0,,然后第二点，刚刚的代码把两个绘图的数全部取出来了,但是啊，正常来说现在两个绘图的结构不是\N统一的吗，既然结构一样，那两个绘图的点个数肯定也一样啊，那干嘛需要coor1和coor2两个表呢\N直接把第二个绘图的点取出来不就好了？因为你gsub替换的时候不是替换的第一个绘图的点吗，那\N你搜索替换的时候就能直接得到第一个绘图的数啊,不需要单独for循环取出来放coor1里啊。再然后\N之前是一次匹配一个数，但是你也可以一次匹配一个点啊，用上分组匹配、用上可爱的()括号
Dialogue: 0,0:40:29.11,0:40:37.11,Default,,0,0,0,,这样替换的时候，直接替换掉一个点(也就是一个x坐标，一个y坐标)即可
Dialogue: 0,0:40:44.44,0:41:05.99,Default,,0,0,0,,原本代码for循环遍历出了绘图一的点,然后在gsub替换的时候使用coor1[cnt]，但是当然cor1[cnt]\N{\fs35}不就是你gsub此时匹配到的东西吗。所以现在匹配到一个点,那么计算新的x时用x+(coor2[cnt].x-x)*pct^a即可
Dialogue: 0,0:41:05.99,0:41:27.99,Default,,0,0,0,,然后这样的话，最后替换的东西就该是[-.%d]+ [-.%d]+这个东西，所以最后return的应该是个这\N样结构的字符串，所以你实际上return的是x.." "..y这种东西，当然这里还要取舍一下x和y的小数
Dialogue: 0,0:42:22.81,0:43:01.99,Default,,0,0,0,,那既然toshape_at_pct函数里删除了将输入的俩绘图结构统一的代码,所以现在用这个函数时参数就\N必须要填两个结构统一的绘图(当然有直线也无所谓,因为只要结构统一就能用该算法进行gsub替换)\N所以现在还可以把这句也删掉，因为在下面的toshape函数中一开始就把两个绘图全部统一结构了,\N而且它统一结构后就全是贝塞尔路径了,所以不删反而{\fs39}会增加文本量,没必要让toshape_at_pct函数再\N这样直接返回了。
Dialogue: 0,0:43:24.43,0:44:14.16,Default,,0,0,0,,为了节约一点文本量，就让shapes这个表一开始就装入绘图一和绘图二，它分别是第一个元素和最\N后一个元素，也就是pct=0时变形进度为0，所以绘图一还没开始变形呢，所以此时就是绘图一本身\N而pct=1变形进度为1时，刚好从绘图一变形为绘图二，所以此时就是绘图二本身，所以shapes表的\N最后一个元素直接一开始就等于绘图二即可。那么这样加了两个以后，循环就不是从1到loop了，而\N是2到loop-1了对吧，这个应该很好理解,因为第一个图形和最后一个图形已经添加进shapes表里了\N不需要再循环产生了。
Dialogue: 0,0:45:24.18,0:45:30.48,Default,,0,0,0,,好,把刚刚改的代码保存以后，再在aeg里重新加载一下
Dialogue: 0,0:45:31.28,0:45:58.99,Default,,0,0,0,,然后直接来看一下简单的应用\N比如这里先生成文字绘图，然后当然,绘图必须要是"标准"的才能用刚刚讲的函数，所以要用之前讲\N的函数将其绘图代码"标准化"，然后将绘图稍微平移一下，将其的中心移动到0,0点，方便变形,因为\N你做变形效果的绘图一般中心都在0,0点才方便吧
Dialogue: 0,0:46:07.51,0:46:24.34,Default,,0,0,0,,然后还是用刚才的toshape函数，现在是要把一个绘图给变化为文字绘图text\N注意修饰语不要弄错了，现在你这绘图要变成一个字一个字的文字绘图,所以当然不要用code line
Dialogue: 0,0:46:24.34,0:46:37.55,Default,,0,0,0,,当然现在这里设定的开始时间和结束时间和刚才不一样,现在的开始时间是行开始时间，而持续时间\N是行持续时间的1/3，所以结束时间就不是刚才举例中的行结束时间了
Dialogue: 0,0:46:37.55,0:46:45.99,Default,,0,0,0,,然后当然，文字绘图平移到0,0以后，pos的定位就该是$center,$middle了
Dialogue: 0,0:46:48.99,0:47:20.36,Default,,0,0,0,,然后来看看连续变形的效果
Dialogue: 0,0:48:03.69,0:48:11.74,Default,,0,0,0,,当然变形的过程是从行开始时间开始，然后持续了行持续时间的1/3，然后就变形完成了
Dialogue: 0,0:49:09.68,0:49:46.64,Default,,0,0,0,,然后刚才说了，在下一次更新教程的时候再讲如何用又快又好的方法实现这种变形效果\N介绍如何节约文本量、不产生这么多b命令、而且执行速度更快的函数
